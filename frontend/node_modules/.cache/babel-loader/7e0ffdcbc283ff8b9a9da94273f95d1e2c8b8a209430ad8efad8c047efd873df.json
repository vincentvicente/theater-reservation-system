{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nexport function autoPtgSizes(ptgSizes, minPtgSizes, maxPtgSizes) {\n  // Static current data\n  let currentTotalPtg = 0;\n  const undefinedIndexes = [];\n  ptgSizes.forEach((size, index) => {\n    if (size === undefined) {\n      undefinedIndexes.push(index);\n    } else {\n      currentTotalPtg += size;\n    }\n  });\n  const restPtg = 1 - currentTotalPtg;\n  const undefinedCount = undefinedIndexes.length;\n  // Fill if exceed\n  if (restPtg < 0) {\n    const scale = 1 / currentTotalPtg;\n    return ptgSizes.map(size => size === undefined ? 0 : size * scale);\n  }\n  // Check if limit exists\n  let sumMin = 0;\n  let sumMax = 0;\n  let limitMin = 0;\n  let limitMax = 1;\n  for (const index of undefinedIndexes) {\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    sumMin += min;\n    sumMax += max;\n    limitMin = Math.max(limitMin, min);\n    limitMax = Math.min(limitMax, max);\n  }\n  // Impossible case, just average fill\n  if (sumMin > 1 && sumMax < 1) {\n    const avg = 1 / undefinedCount;\n    return ptgSizes.map(size => size === undefined ? avg : size);\n  }\n  // Quickly fill if can\n  const restAvg = restPtg / undefinedCount;\n  if (limitMin <= restAvg && restAvg <= limitMax) {\n    return ptgSizes.map(size => size === undefined ? restAvg : size);\n  }\n  // Greedy algorithm\n  const result = _toConsumableArray(ptgSizes);\n  let remain = restPtg - sumMin;\n  for (let i = 0; i < undefinedCount; i += 1) {\n    const index = undefinedIndexes[i];\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    result[index] = min;\n    const canAdd = max - min;\n    const add = Math.min(canAdd, remain);\n    result[index] += add;\n    remain -= add;\n  }\n  return result;\n}","map":{"version":3,"names":["_toConsumableArray","autoPtgSizes","ptgSizes","minPtgSizes","maxPtgSizes","currentTotalPtg","undefinedIndexes","forEach","size","index","undefined","push","restPtg","undefinedCount","length","scale","map","sumMin","sumMax","limitMin","limitMax","min","max","Math","avg","restAvg","result","remain","i","canAdd","add"],"sources":["/Users/vicentezhu/Desktop/theater-reservation-system/frontend/node_modules/antd/es/splitter/hooks/sizeUtil.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nexport function autoPtgSizes(ptgSizes, minPtgSizes, maxPtgSizes) {\n  // Static current data\n  let currentTotalPtg = 0;\n  const undefinedIndexes = [];\n  ptgSizes.forEach((size, index) => {\n    if (size === undefined) {\n      undefinedIndexes.push(index);\n    } else {\n      currentTotalPtg += size;\n    }\n  });\n  const restPtg = 1 - currentTotalPtg;\n  const undefinedCount = undefinedIndexes.length;\n  // Fill if exceed\n  if (restPtg < 0) {\n    const scale = 1 / currentTotalPtg;\n    return ptgSizes.map(size => size === undefined ? 0 : size * scale);\n  }\n  // Check if limit exists\n  let sumMin = 0;\n  let sumMax = 0;\n  let limitMin = 0;\n  let limitMax = 1;\n  for (const index of undefinedIndexes) {\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    sumMin += min;\n    sumMax += max;\n    limitMin = Math.max(limitMin, min);\n    limitMax = Math.min(limitMax, max);\n  }\n  // Impossible case, just average fill\n  if (sumMin > 1 && sumMax < 1) {\n    const avg = 1 / undefinedCount;\n    return ptgSizes.map(size => size === undefined ? avg : size);\n  }\n  // Quickly fill if can\n  const restAvg = restPtg / undefinedCount;\n  if (limitMin <= restAvg && restAvg <= limitMax) {\n    return ptgSizes.map(size => size === undefined ? restAvg : size);\n  }\n  // Greedy algorithm\n  const result = _toConsumableArray(ptgSizes);\n  let remain = restPtg - sumMin;\n  for (let i = 0; i < undefinedCount; i += 1) {\n    const index = undefinedIndexes[i];\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    result[index] = min;\n    const canAdd = max - min;\n    const add = Math.min(canAdd, remain);\n    result[index] += add;\n    remain -= add;\n  }\n  return result;\n}"],"mappings":"AAAA,OAAOA,kBAAkB,MAAM,8CAA8C;AAC7E,OAAO,SAASC,YAAYA,CAACC,QAAQ,EAAEC,WAAW,EAAEC,WAAW,EAAE;EAC/D;EACA,IAAIC,eAAe,GAAG,CAAC;EACvB,MAAMC,gBAAgB,GAAG,EAAE;EAC3BJ,QAAQ,CAACK,OAAO,CAAC,CAACC,IAAI,EAAEC,KAAK,KAAK;IAChC,IAAID,IAAI,KAAKE,SAAS,EAAE;MACtBJ,gBAAgB,CAACK,IAAI,CAACF,KAAK,CAAC;IAC9B,CAAC,MAAM;MACLJ,eAAe,IAAIG,IAAI;IACzB;EACF,CAAC,CAAC;EACF,MAAMI,OAAO,GAAG,CAAC,GAAGP,eAAe;EACnC,MAAMQ,cAAc,GAAGP,gBAAgB,CAACQ,MAAM;EAC9C;EACA,IAAIF,OAAO,GAAG,CAAC,EAAE;IACf,MAAMG,KAAK,GAAG,CAAC,GAAGV,eAAe;IACjC,OAAOH,QAAQ,CAACc,GAAG,CAACR,IAAI,IAAIA,IAAI,KAAKE,SAAS,GAAG,CAAC,GAAGF,IAAI,GAAGO,KAAK,CAAC;EACpE;EACA;EACA,IAAIE,MAAM,GAAG,CAAC;EACd,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAIC,QAAQ,GAAG,CAAC;EAChB,KAAK,MAAMX,KAAK,IAAIH,gBAAgB,EAAE;IACpC,MAAMe,GAAG,GAAGlB,WAAW,CAACM,KAAK,CAAC,IAAI,CAAC;IACnC,MAAMa,GAAG,GAAGlB,WAAW,CAACK,KAAK,CAAC,IAAI,CAAC;IACnCQ,MAAM,IAAII,GAAG;IACbH,MAAM,IAAII,GAAG;IACbH,QAAQ,GAAGI,IAAI,CAACD,GAAG,CAACH,QAAQ,EAAEE,GAAG,CAAC;IAClCD,QAAQ,GAAGG,IAAI,CAACF,GAAG,CAACD,QAAQ,EAAEE,GAAG,CAAC;EACpC;EACA;EACA,IAAIL,MAAM,GAAG,CAAC,IAAIC,MAAM,GAAG,CAAC,EAAE;IAC5B,MAAMM,GAAG,GAAG,CAAC,GAAGX,cAAc;IAC9B,OAAOX,QAAQ,CAACc,GAAG,CAACR,IAAI,IAAIA,IAAI,KAAKE,SAAS,GAAGc,GAAG,GAAGhB,IAAI,CAAC;EAC9D;EACA;EACA,MAAMiB,OAAO,GAAGb,OAAO,GAAGC,cAAc;EACxC,IAAIM,QAAQ,IAAIM,OAAO,IAAIA,OAAO,IAAIL,QAAQ,EAAE;IAC9C,OAAOlB,QAAQ,CAACc,GAAG,CAACR,IAAI,IAAIA,IAAI,KAAKE,SAAS,GAAGe,OAAO,GAAGjB,IAAI,CAAC;EAClE;EACA;EACA,MAAMkB,MAAM,GAAG1B,kBAAkB,CAACE,QAAQ,CAAC;EAC3C,IAAIyB,MAAM,GAAGf,OAAO,GAAGK,MAAM;EAC7B,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,cAAc,EAAEe,CAAC,IAAI,CAAC,EAAE;IAC1C,MAAMnB,KAAK,GAAGH,gBAAgB,CAACsB,CAAC,CAAC;IACjC,MAAMP,GAAG,GAAGlB,WAAW,CAACM,KAAK,CAAC,IAAI,CAAC;IACnC,MAAMa,GAAG,GAAGlB,WAAW,CAACK,KAAK,CAAC,IAAI,CAAC;IACnCiB,MAAM,CAACjB,KAAK,CAAC,GAAGY,GAAG;IACnB,MAAMQ,MAAM,GAAGP,GAAG,GAAGD,GAAG;IACxB,MAAMS,GAAG,GAAGP,IAAI,CAACF,GAAG,CAACQ,MAAM,EAAEF,MAAM,CAAC;IACpCD,MAAM,CAACjB,KAAK,CAAC,IAAIqB,GAAG;IACpBH,MAAM,IAAIG,GAAG;EACf;EACA,OAAOJ,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}